--DQL(질의하는 어=물어보는,데이터 조회한다)
--select  컬럼 명
--from 테이블 명

--전체데이터
select empno,ename,job,mgr,hiredate,sal,comm,deptno
from emp; 

select * 
from emp;

--부분 3개 데이터
select empno,ename,sal
from emp;

--부분 1개 데이터
select deptno
from emp;

select DISTINCT(deptno)--중복된건 제외
from emp;

select job
from emp;

select DISTINCT(job)
from emp;
--데이터를 통해서 연산자 사용할 수 있다.-,+,/,*
--컬럼대상으로 연산한다
--null값은 연산이 불가하다.
--컬럼에 별칭을 사용할 수 있다.
select ename as 사원명 ,sal,sal*12+nvl(comm,0)as 연봉,comm--(comm,0)= comm이 0으로 한다
from emp;--as연봉=> sal*12+nvl이 부분이 연봉으로 이름이 바뀐다


----------------------------------------------------------------10.18일
--order by=> 정렬기준이 되는 값 ex)asc(오름차순)/desc(내림차순)
select * 
from emp 
order by sal asc;--오름차순은 생략이 가능하다 =>생략된 상태면 오름차순으로 실행된다
--숫자(1~10),날짜(과거날짜~최신날짜), 문자(사전순서대로),

--------------------------------------조건검색,연산자,
--select컬럼명, from테이블형, where 조건식(컬럼명 =값)ex <,>,=,!=,/,<=,>=,and,or
select * 
from emp
where sal >=3000; --급여가 3000이상인 사원들 출력

select *
from emp
where deptno =30;--deptno가 30인 사원들

--and는 두가지 조건이 모두 참인 경우 쓴다
select *
from emp               --오라클에서는 ''로 문자열쓴다
where deptno =30 and  job = 'SALESMAN'and  empno = 7499;

select *
from emp
where ename = 'FORD';
--소문자 ford는 없고 대문자 FORD가 있어서 출력할때 안나온다 


-------------------------날짜를 조건절에 사용할 때
------------------날짜도 크기 비교가 있고, ''을 사용한다
select *
from emp
where hiredate < '1982/01/01';


----------------or은 두개이상의 조건중에 하나이상 참인 경우
select *
from emp
where deptno = 10 or sal >=2000;


-------------------not 논리부정 연산자 1번째 방법 (!=)
select *
from emp
where sal !=3000;
--2번째 방법 (not)
select *
from emp 
where not sal = 3000;


----------------------and,or 범위 조건을 표현 할 때 사용
select *
from emp
where sal >= 1000 and sal <=3000;

select *
from emp
where sal <=1000 or sal >=3000;

-------------------------between and  ,in,like
select *
from emp
where sal not between 1000 and 3000;

select *
from emp
where sal= 800 or sal =3000 or sal=5000;
--in 을 써서 위 코드와 동일한 결과 값이 나온다
select *
from emp
where sal in(800,3000,5000);

--------------------like은 값의 일부만 가지고 데이터를 조회한다.
--와일드 카드를 사용한다(%,_) %는 모든 문자를 대체,, _는 한 문자를 대체한다
select *
from emp
where ename like 'F%';--이름이 F로 시작하는 사람들 출력

select *
from emp
where ename like '%D';--이름이 D로 끝나는 사람들 출력

select *
from emp
where ename like '%O%';--이름이 시작 또는 끝이 O(대문자)로 되는 사람들 출력

select *
from emp
where ename like  '___D'; -- _(언더바)3글자이면서 마지막글자 D인 사람들 출력

select *
from emp
where ename like 'S__%';--S로 시작 하고 언더바 2개 이상인 사람들 <= % 때문에

---------------------- null 연산자 (is null/is not null)
select *
from emp
where comm is null;

-----------------------------집합연산자
--차집합(MINUS),합집합(UNION),교집합(INTERSECT)
--처음select에 ;를 안쓴다
--2개의 select구문을 사용,컬럼의 갯수가 동일,컬럼의 타입이 동일,컬럼의 이름은 상관없다.

--합집합
select empno,ename,sal,deptno
from emp
where deptno = 20
UNION 
select empno,ename,sal,deptno
from emp
where deptno = 10;
--중복은 출력안되지만 All 사용하면서 중복된것도 출력된다
select empno,ename,sal,deptno
from emp
where deptno = 10
UNION ALL
select empno,ename,sal,deptno
from emp
where deptno = 10;

--차집합
select empno,ename,sal,deptno
from emp 
MINUS 
select empno,ename,sal,deptno
from emp
where deptno = 10;

--교집합
select empno,ename,sal,deptno
from emp
INTERSECT 
select empno,ename,sal,deptno
from emp
where deptno = 10;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO in (20,30)
INTERSECT
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
where SAL > 2000;

--전체데이터
select empno,ename,job,mgr,hiredate,sal,comm,deptno
from emp; 

select * 
from emp;

--부분 3개 데이터
select empno,ename,sal
from emp;

--부분 1개 데이터
select deptno
from emp;

select DISTINCT(deptno)--중복된건 제외
from emp;

select job
from emp;

select DISTINCT(job)
from emp;
--데이터를 통해서 연산자 사용할 수 있다.-,+,/,*
--컬럼대상으로 연산한다
--null값은 연산이 불가하다.
--컬럼에 별칭을 사용할 수 있다.
select ename as 사원명 ,sal,sal*12+nvl(comm,0)as 연봉,comm--(comm,0)= comm이 0으로 한다
from emp;--as연봉=> sal*12+nvl이 부분이 연봉으로 이름이 바뀐다


----------------------------------------------------------------10.18일
--p.85~

--order by=> 정렬기준이 되는 값 ex)asc(오름차순)/desc(내림차순)
select * 
from emp 
order by sal asc;--오름차순은 생략이 가능하다 =>생략된 상태면 오름차순으로 실행된다
--숫자(1~10),날짜(과거날짜~최신날짜), 문자(사전순서대로),

--------------------------------------조건검색,연산자,
--select컬럼명, from테이블형, where 조건식(컬럼명 =값)ex <,>,=,!=,/,<=,>=,and,or
select * 
from emp
where sal >=3000; --급여가 3000이상인 사원들 출력

select *
from emp
where deptno =30;--deptno가 30인 사원들

--and는 두가지 조건이 모두 참인 경우 쓴다
select *
from emp               --오라클에서는 ''로 문자열쓴다
where deptno =30 and  job = 'SALESMAN'and  empno = 7499;

select *
from emp
where ename = 'FORD';
--소문자 ford는 없고 대문자 FORD가 있어서 출력할때 안나온다 


-------------------------날짜를 조건절에 사용할 때
------------------날짜도 크기 비교가 있고, ''을 사용한다
select *
from emp
where hiredate < '1982/01/01';


----------------or은 두개이상의 조건중에 하나이상 참인 경우
select *
from emp
where deptno = 10 or sal >=2000;


-------------------not 논리부정 연산자 1번째 방법 (!=)
select *
from emp
where sal !=3000;
--2번째 방법 (not)
select *
from emp 
where not sal = 3000;


----------------------and,or 범위 조건을 표현 할 때 사용
select *
from emp
where sal >= 1000 and sal <=3000;

select *
from emp
where sal <=1000 or sal >=3000;

-------------------------between and  ,in,like
select *
from emp
where sal not between 1000 and 3000;

select *
from emp
where sal= 800 or sal =3000 or sal=5000;
--in 을 써서 위 코드와 동일한 결과 값이 나온다
select *
from emp
where sal in(800,3000,5000);

--------------------like은 값의 일부만 가지고 데이터를 조회한다.
--와일드 카드를 사용한다(%,_) %는 모든 문자를 대체,, _는 한 문자를 대체한다
select *
from emp
where ename like 'F%';--이름이 F로 시작하는 사람들 출력

select *
from emp
where ename like '%D';--이름이 D로 끝나는 사람들 출력

select *
from emp
where ename like '%O%';--이름이 시작 또는 끝이 O(대문자)로 되는 사람들 출력

select *
from emp
where ename like  '___D'; -- _(언더바)3글자이면서 마지막글자 D인 사람들 출력

select *
from emp
where ename like 'S__%';--S로 시작 하고 언더바 2개 이상인 사람들 <= % 때문에

---------------------- null 연산자 (is null/is not null)
select *
from emp
where comm is null;

-----------------------------집합연산자
--차집합(MINUS),합집합(UNION),교집합(INTERSECT)
--처음select에 ;를 안쓴다
--2개의 select구문을 사용,컬럼의 갯수가 동일,컬럼의 타입이 동일,컬럼의 이름은 상관없다.

--합집합
select empno,ename,sal,deptno
from emp
where deptno = 20
UNION 
select empno,ename,sal,deptno
from emp
where deptno = 10;
--중복은 출력안되지만 All 사용하면서 중복된것도 출력된다
select empno,ename,sal,deptno
from emp
where deptno = 10
UNION ALL
select empno,ename,sal,deptno
from emp
where deptno = 10;

--차집합
select empno,ename,sal,deptno
from emp 
MINUS 
select empno,ename,sal,deptno
from emp
where deptno = 10;

--교집합
select empno,ename,sal,deptno
from emp
INTERSECT 
select empno,ename,sal,deptno
from emp
where deptno = 10;

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO in (20,30)
INTERSECT
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
where SAL > 2000;


---------------------------------오라클 함수
--소문자 ,대문자 둘 다 출력된다
select 'Welcome',upper('Welcome')
from dual;

select lower(ename),upper(ename)
from emp;

select *
from emp
where ename = 'FORD';

select *
from emp
where lower(ename) = 'scott';
-------------길이
select ename,length(ename)
from emp;
---------------substr
select 'Welcome to Oracle',substr('Welcome to Oracle',1,3)--1~3번째까지를 출력한다
from dual;--Wel 출력된다
select 'Welcome to Oracle',substr('Welcome to Oracle',-17)-- -17번째부터 출력한다
from dual;--Welcome to Oracle 출력

select instr('Welcome to Oracle','o')-- o의 위치를 찾는다
from dual;--5가 출력

select instr('Welcome to Oracle','o',6)-- 6번째를 시작으로하고 다음 o의 위치가 10이다
from dual;--10이출력

select instr('Welcome to Oracle','e',3,2)-- 3번째를 시작으로하고 두번째 e의 출력된다
from dual;--17이 나온다

-----------replace
select 'Welcome to Oracle',replace ('Welcome to Oracle','to','of')-- to를 of 로 바꿔준다
from dual;

-----------LPAD, RPAD
select 'oracle',lpad('oracle',10,'#'),rpad('oracle',10,'*'),lpad('oracle',10)
from dual;--####oracleoracle****    oracle

select rpad('990103-',14,'*')
from dual;--990103-*******

----------------------------10.19일-----------------------------------------
--p.146~
----------------------------날짜함수 --------------------
select sysdate -1 어제, sysdate, sysdate +1 내일
from dual;--22/10/18	22/10/19	22/10/20
----근무일수
select sysdate - hiredate as 근무일수 --차이가 일수 반환
from emp;

----근속년수
select trunc ((sysdate - hiredate)/365) as 근속년수 
from emp;--41  trunc 사용하면서 소수점 삭제된다
--41
--41
--41
--41
--41
--41
--35
--40
--41
--35
--40
--40
--40

select sysdate,
round(sysdate,'cc')as  CC,--네자리 연도 끝 두자리 기준
round(sysdate,'yyyy')as  yyyy, --연원일의 7월 1일 기준
round(sysdate,'Q')as q,--두번째 달의 16일기준
round(sysdate,'DDD')as dd,--해당 일의 정오기준
round(sysdate,'HH')as hh-- 해당일 기준
from dual;

------------------------자료형 변환 함수-------------------------
--to_char()
--to_number()
--to_date()

--날짜를 문자로
select sysdate,to_char(sysdate,'YYYY-MM-DD HH24:MI:SS')as 현재시간
from dual;--22/10/19	2022-10-19 11:02:21

select hiredate,to_char(hiredate,'YYYY-MM-DD HH24:MI:SS')as 현재시간
from emp;--80/12/17	1980-12-17....

--숫자를 문자로
select to_char(123456,'999,999')
from dual;-- 123,456
select to_char(sal,'L999,999')
from emp;

--문자를 숫자로
select 20000-10000 --묵시적형(=자동형)변환
from dual;

select '20,000'-'10,000' --오류가 난다 =>to_number()형변환을 해줘야한다.
from dual;
select to_number('20,000','999,999')- to_number('5,000','999,999')
from dual;

--문자를 날짜로
select to_date('20221019','YYYY/MM/DD')
from dual;--22/10/19

select *
from emp
where hiredate < to_date(' 19820101','YYYY-MM-DD');

----------------------null처리함수----------------------------------
--null데이터처리
--nvl(null,바꾸고 싶은데이터)
--nvl은 null 데이터의 타입과 같은 타입으로 변경해줘야한다.
--nvl(숫자,숫자),nvl(문자,문자)

select ename 사원명,sal,sal*12+nvl(comm,0) as 연봉,comm
from emp;--SMITH 800	9600	null
         --ALLEN 1600	19500	300
         --WARD	 1250	15500	500...

select *
from emp
where mgr is null;--7839	KING	PRESIDENT	81/11/17	5000	10

select ename,job,nvl(to_char(mgr,'9999'),'CEO')as mgr
from emp
where mgr is null;--KING	PRESIDENT	CEO

select comm,nvl2(comm,'O','X')
from emp;

------------------------------조건문 표현하는 함수-----------------------------
--조건문 표현하는 함수
--decode()->switch
--case    ->if

select ename,job,deptno,
decode(deptno,10,'AAA' ,20,'BBB' ,30,'CCC' ,'기타')as 부서명
from emp;

--case문 예시,범위를 조건식으로 설정 할 수 있다.
--case 
--  when'조건식'  then'실행문'
--  when'조건식'  then'실행문'
--  when'조건식'  then'실행문'
--  else'실행문'
--end as 000

select ename,job,deptno,--위에 decode와 같은 값이 출력된다
case 
  when deptno =10  then 'AAA'
  when deptno =20  then 'BBB'
  when deptno =30  then 'CCC'
  else'기타'
  end as 부서명
from emp;

select ename,job,sal,
case 
  when sal between 3000 and 5000 then'임원'
  when sal >=2000 and sal <3000 then'관리자'   
  when sal >=500 and sal<2000 then'사원'
    else'기타'
    end as 직무
from emp;

--6-1문제
select empno,rpad(substr(empno,1,2),4,'*')as MASKING_ENPNO,
       ename,
       rpad(substr(ename,1,1),length(ename),'*')as MASKING_ENAME
  from emp
 where length(ename) >=5 --length 문자열구하기
   and length(ename) < 6;
--6-2문제
select empno,ename,sal,
      trunc(sal/21.5,2) as day_pay,--하루일당 월급에 21.5 나누고  소수점 2째 짜리까지 살리고 3번째자리에서 반올림한다. 
      round(sal/21.5/8,1)as TIME_PAY--시간당시급 21.5/8 나누고 소수점 1째자리까지 출력 2번째자리에서 반올림
      from emp;
      
--6-4문제
select empno,ename,mgr,
case
when mgr is null then '0000'
when substr(mgr,1,2)='78' then'8888' --1번째 시작해서2번째까지 78인 사원은 8888
when substr(mgr,1,2)='77' then'7777'
when substr(mgr,1,2)='76' then'6666'
when substr(mgr,1,2)='75' then'5555'
else to_char(mgr)
end as chg_mgr
from emp;

------------------------다중행함수--------------------------
--일반컬럼과 같이 쓸 수 없다,
--크기비교가 가능 모두 타입에 사용가능
--sum: 00열 값을 모두 합한 결과 값이 하나의 행으로 출력된다.
select sum(sal)
from emp;
--avg:00열 값을 합한 평균 결과 값이 하나의 행으로 출력된다.
select avg(sal)
from emp;
--count:전체 레코드 개수가 출력된다.
select count(*),count(comm)
from emp;
--max:지정한 데이터 중 최대값출력 <-> min
select max(sal),min(sal)
from emp;

select ename max(sal)
from emp;--오류가 난다 <=ename은 개수가14 != max(sal)은 개수가 1개여서 미스매칭

select min(hiredate)--입사일 가장 빠른사람<->max 입사가 가장 최근인 사원
from emp;
where deptno =20;--부서인원이 20명중

-------암기사항--------------------------------------
--select 컬럼명(열)
--from 테이블명
--where 조건식(그룹합수 사용불가/반드시 group by,having보다 먼저실행!!)
--group by 컬럼명
--having 조건식(그룹함수 사용한다)
--order by 컬럼명 정렬방식=>맨 마지막에 작성한다

------------------------group by절---------------------------------
--각 부서의 평균 값을 한번에 출력 ,      아래와 차이점: 하나하나 지정 해야된다
select avg(sal) from emp where deptno =10
union
select avg(sal) from emp where deptno =20
union
select avg(sal) from emp where deptno =30; 
--group by를 이용한 평균값 한번에 출력,   위에와 차이점: 한번에 가능하다
select avg(sal),deptno    --출력값이 3개 동일해서 오류가 안나온다.
from emp
group by deptno;

select avg(sal),deptno,job
from emp
group by deptno,job
order by deptno,job desc;-- 전체가 정렬되고 job은 내림차순으로 정렬된다.

-------------------------------having절--------------------------
select  deptno,avg(sal)
from emp
group by deptno
having avg(sal) >= 2000;    --group by의해서 조회 결과에 조건을 준다,\
                            --조건식을 작성할 때 그룹함수를 사용한다. 

-------------------------------10.20일-------------------------------------
--p215~
--------------------조인(join)
--2개이상의 테이블에서 데이터를 조회
--from절에 두개이상의 테이블을 작성한다.
--join할때 where에 작성을 해야 한다.
--cross join : 사용은 안함(where절 없이 조인함)
--equi join : 제일 많이 사용됨(where절 사용 등가연산자 : =)
--non equi join : (where 범위연산자 : and ,or)
--self join : where 하나의 테이블을 사용한다.
--out join  :  (=외부조인)등가시 누락되는 데이트를 같이 조회 하기위해서 사용 (+)를 사용한다

select emp.ename,emp.job,emp.deptno,dept.dname,dept.loc--dname 부서이름, loc 근무지
from emp,dept
where emp.deptno=dept.deptno;

select ename,job,e.deptno,dname,loc--양쪽에 이름이 같을 때 컬럼은 소속을 밝혀줘야한다.ex)deptno가 같이 사용됨
from emp  e,dept  d--테이블에 별칭 e, d 를 쓰면서 where절에도 emp->e ,dept->d로 바꿔준다
where e.deptno=d.deptno;  --select의 별칭설정은 4가지 vs from절 별칭은 한 칸 띄어쓰기 사용한다.

--equi join
select ename,job,e.deptno,dname,loc,sal
from emp  e,dept  d
where e.deptno=d.deptno
and sal >=3000;  

--non equi join
select ename,sal,grade,losal,hisal
from emp e,salgrade s
where e.sal bewteen s.losal and s.hisal;--  between and 절 사용 밑에꺼와 동일한 결과 값을 출력한다.
--where e.sal >= s.losal and  e.sal <= s.hisal;--non equi join절 사용

--사번,이름,급여, /부서번호 ,부서명, /급여등급
--emp에 위치     /dept에 위치      /salgrade

select empno,ename,sal,d.deptno,dname,grade
from emp e,dept d, salgrade s
where e. deptno = d.deptno
and e.sal between s.losal and s.hisal;

----self join  --하나의 테이블을 2개로 분리한다고 생각
select e.empno ,e.ename,e.mgr,m.ename
from emp e,emp m--반드시 별칭부여
where e.mgr = m.empno;

select ename,deptno
from emp
where deptno =20;
--SMITH	20
--JONES	20
--SCOTT	20
--ADAMS	20
--FORD	20


--scott와 같은 부서에 근무하는 사원 -self join 으로 출력해보기
--ename  ename 
--scott  simth
--scott  JONES
--scott  ADAMS
--scott  FORD                     
select  work.ename , friend.ename-- work->w, friend->f 로 별칭해서 가능
from emp work,emp friend
where work.deptno = friend.deptno
and work.ename = 'SCOTT'
and friend.ename != 'SCOTT';
--SCOTT	SMITH
--SCOTT	JONES
--SCOTT	ADAMS
--SCOTT	FORD

------out join
select e.empno ,e.ename,e.mgr,m.ename
from emp e,emp m --밑에 코드와 deptno의 40을 제외하고 값은 결과다
where e.mgr = m.empno(+);--데이터가 없는 테이블쪽에 (+)를 붙인다.=>king이 나오게된다

select ename,sal,d.deptno,dname
from emp e,dept d
where e.deptno(+) = d.deptno; --(+)를 사용하면서 =>deptno의 40이 출력된다.
--SMITH	800	20	RESEARCH
--ALLEN	1600	30	SALES
--WARD	1250	30	SALES
--JONES	2975	20	RESEARCH
--MARTIN	1250	30	SALES
--BLAKE	2850	30	SALES
--CLARK	2450	10	ACCOUNTING
--SCOTT	3000	20	RESEARCH
--KING	5000	10	ACCOUNTING
--TURNER	1500	30	SALES
--ADAMS	1100	20	RESEARCH
--JAMES	950	30	SALES
--FORD	3000	20	RESEARCH
--MILLER	1300	10	ACCOUNTING
--null	40	OPERATIONS


-------ANSI-JOIN(표준조인방식)
--cross join, natural join : 잘 사용안한다
--inner join(equi,non equi,self join)
--outer join((+)) [left or right or full] outer join

--inner join
select ename,sal,dname,loc
from emp e inner join dept d
using(deptno) --양쪽 테이블의 컬럼명이 동일한경우
where ename = 'SCOTT';--SCOTT 3000 RESEARCH	DALLAS

select e.empno,e.ename,e.mgr,m.ename
from emp e inner join emp m
on e.mgr = m.empno;
--7902	FORD	7566	JONES
--7788	SCOTT	7566	JONES
--7900	JAMES	7698	BLAKE
--7844	TURNER	7698	BLAKE
--7654	MARTIN	7698	BLAKE
--7521	WARD	7698	BLAKE
--7499	ALLEN	7698	BLAKE
--7934	MILLER	7782	CLARK
--7876	ADAMS	7788	SCOTT
--7782	CLARK	7839	KING
--7698	BLAKE	7839	KING
--7566	JONES	7839	KING
--7369	SMITH	7902	FORD

select empno,ename,sal,grade
from emp e inner join salgrade s--inner join을 쓸경우 on 형태가 따라온다.
on e.sal between s.losal and s.hisal;
--7369	SMITH	800	    1
--7900	JAMES	950	    1
--7876	ADAMS	1100    1
--7521	WARD	1250	2
--7654	MARTIN	1250	2
--7934	MILLER	1300	2
--7844	TURNER	1500	3
--7499	ALLEN	1600	3
--7782	CLARK	2450	4
--7698	BLAKE	2850	4
--7566	JONES	2975	4
--7788	SCOTT	3000	4
--7902	FORD	3000	4
--7839	KING	5000	5

select e.empno,e.ename,e.mgr,m.ename
from emp e left outer join emp m --데이터가 있는 쪽을 지정한다.
on e.mgr = m.empno;--null 킹값이 나온다
--7902	FORD	7566	JONES
--7788	SCOTT	7566	JONES
--7900	JAMES	7698	BLAKE
--7844	TURNER	7698	BLAKE
--7654	MARTIN	7698	BLAKE
--7521	WARD	7698	BLAKE
--7499	ALLEN	7698	BLAKE
--7934	MILLER	7782	CLARK
--7876	ADAMS	7788	SCOTT
--7782	CLARK	7839	KING
--7698	BLAKE	7839	KING
--7566	JONES	7839	KING
--7369	SMITH	7902	FORD
--7839	KING	null	null

select empno,ename,sal,d.deptno,dname,grade
from emp e inner join dept d
on e. deptno = d.deptno
inner join salgrade s
on e.sal between s.losal and s.hisal;
--7369	SMITH	800	20	RESEARCH	    1
--7900	JAMES	950	30	SALES	        1
--7876	ADAMS	1100	20	RESEARCH	1
--7521	WARD	1250	30	SALES	    2
--7654	MARTIN	1250	30	SALES	    2
--7934	MILLER	1300	10	ACCOUNTING	2
--7844	TURNER	1500	30	SALES	    3
--7499	ALLEN	1600	30	SALES	    3
--7782	CLARK	2450	10	ACCOUNTING	4
--7698	BLAKE	2850	30	SALES	    4
--7566	JONES	2975	20	RESEARCH	4
--7788	SCOTT	3000	20	RESEARCH	4
--7902	FORD	3000	20	RESEARCH	4
--7839	KING	5000	10	ACCOUNTING	5

select ename,sal,d.deptno,dname
from emp e,dept d
where e.deptno(+) = d.deptno; 
--ANSI join 방식으로 위와 같은 결과값 출력
select ename,sal,d.deptno,dname
from emp e right outer join dept d
on e.deptno = d.deptno;
--SMITH	800	20	RESEARCH
--ALLEN	1600	30	SALES
--WARD	1250	30	SALES
--JONES	2975	20	RESEARCH
--MARTIN	1250	30	SALES
--BLAKE	2850	30	SALES
--CLARK	2450	10	ACCOUNTING
--SCOTT	3000	20	RESEARCH
--KING	5000	10	ACCOUNTING
--TURNER	1500	30	SALES
--ADAMS	1100	20	RESEARCH
--JAMES	950	30	SALES
--FORD	3000	20	RESEARCH
--MILLER	1300	10	ACCOUNTING
--null	null 	40	OPERATIONS

--8-1문제
select d.deptno, d.dname , e.empno, e.ename, e.sal
from emp e, dept d
where e.deptno= d.deptno
and e.sal>2000;
--inner 방식으로
select d.deptno, d.dname , e.empno, e.ename, e.sal
from emp e inner join dept d
on e.deptno= d.deptno
where e.sal>2000;


--8-2문제
select d.deptno,d.dname, --콤마(,)표시 하기
trunc(avg(sal)) as avg_sal,
max(sal) as max_sal,
min(sal) as min_sal,
count(*) as cnt
from emp e, dept d
where e.deptno = d.deptno
group by d.deptno,d.dname;

select d.deptno,d.dname, 
trunc(avg(sal)) as avg_sal,
max(sal) as max_sal,
min(sal) as min_sal,
count(*) as cnt
from emp e inner join  dept d
on e.deptno = d.deptno
group by d.deptno,d.dname;

--8-3문제
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E, DEPT D
 WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
  FROM EMP E right outer join DEPT D--e.deptno 포함시킨다??
  on e.deptno = d.deptno
  order by d.deptno, e.ename;


--8-4문제
SELECT D.DEPTNO, D.DNAME,
       E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
       S.LOSAL, S.HISAL, S.GRADE,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
  FROM EMP E, DEPT D, SALGRADE S, EMP E2
 WHERE E.DEPTNO(+) = D.DEPTNO
   AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
   AND E.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E.EMPNO; 

select d.deptno,d.dname,e.empno,e.ename,e.mgr,e.sal,e.deptno,
s.losal,s.hisal,s.grade,m.empno,m.ename
from emp e right outer join dept d
on e.deptno = d.deptno
   full outer join salgrade s
on e.sal between s. losal and s. hisal
   left outer join emp m 
on e.mgr = m.empno
   order by d.deptno, e.empno;
   
   --------------------------------서브쿼리--------------------------------
   
   --select 구문을 중첩해서 사용하는 것(where)
   select ename,max(sal)
   from emp;--개수차이(여러개,1개)가 나서 오류가 난다
   
   select ename,sal
   from emp
   where sal = (
                select max(sal)
                from emp
                );--KING	5000
   
   select deptno
   from emp
   where ename ='SCOTT'
   20;
   
   select dname
   from dept
   where deptno =20;--RESEARCH
   
   select dname--메인 쿼리
   from dept
   where deptno =(select deptno--서브쿼리
                  from emp
                  where ename ='SCOTT');--RESEARCH
   
   select ename,deptno
   from emp
   where deptno = (select deptno
                   from dept
                   where loc = 'DALLAS');
--SMITH	20                   
--JONES	20
--SCOTT	20
--ADAMS	20
--FORD	20


--자신의 직속상관이 king 인 사원의 이름과 급여를 조회하세요.
select ename,sal,mgr
from emp
where mgr =(select empno
            from emp
            where ename = 'KING');
--JONES	2975
--BLAKE	2850
--CLARK	2450

----다중행서브쿼리----------------p254
-- in   : 결과중에 하나가 만족하면된다.
-- >any : 결과중에 가장 작은값보다 크면된다
-- >all : 결과중에 가장 큰값 보다 크면된다.
select*
from emp
where sal in (5000,3000,2850);
--위와 같은 값 출력된다.

select*
from emp
where sal >any ( -- '<any'를 in으로 바꿔도 같은 값이 나온다.의미는가장 큰값보다 작은값  <-->  '>' 가장 작은값보다 큰값
              select max(sal)
              from emp
              group by deptno);
--7566	JONES	MANAGER	7839	81/04/02	2975		20
--7788	SCOTT	ANALYST	7566	87/04/19	3000		20
--7839	KING	PRESIDENT		81/11/17	5000		10
--7902	FORD	ANALYST	7566	81/12/03	3000		20 

select ename,sal,deptno
from emp 
where sal > all (select sal  --all 가장큰값보다 큰값 <--> '<all'최소급여보다 더 적은 값
                 from emp
                 where deptno = 30);
              
-----다중열 서브쿼리
select*
from emp
where (deptno,sal) in (select deptno,max(sal)
                       from emp
                       group by deptno);




------------------------------------------10.21------------------------------
--p.266~

--DML(데이터조작어) : insert, update , delete
--insert : 테이블에 데이터 삽입
--insert into 테이블명 (컬럼명1,컬럼명2,...)
--values (값1,값2....)
--컬럼과 값의 타입과 갯수가 일치해야 한다.( 1 : 1 )
--작성 순서대로 1:1매칭된다

create table dept_temp
as
select * from dept;

select *
from dept_temp;

insert into dept_temp(deptno,dname,loc)
values(50,'DATABASE','SEOUL');--'50 DATABASE SEOUL'가 dept_temp테이블에 추가됨

insert into dept_temp(deptno,dname)--2개만 넣고 싶은경우 loc는 null로 삽입된다
values(60,'JSP');--null의 묵시적 삽입

insert into dept_temp--컬럼생략 될 때 => 3개의 열을 똑같이 행이 삽입된다.
values(70,'HTML','SEOUL');

insert into dept_temp--컬럼생략, 명시적 null데이터 삽입
values(80,'null','SEOUL');-- => 3개의 열을 똑같이 행이 삽입된다.

create table emp_temp
as
select * from emp
where 1 != 1;

select *
from emp_temp;

insert into emp_temp(empno,ename,job,mgr,hiredate,sal,comm,deptno)
values(9999,'홍길동','PRESIDENT',null,'2001/01/01',5000,1000,10);

insert into emp_temp(empno,ename,job,mgr,hiredate,sal,comm,deptno)
values (3111,'심청이','MANGER',9999,sysdate,4000,null,30);

-------------update
--update : 컬럼의 데이터를 변경(수정)
--update 테이블명
--set 컬럼명 =값,컬럼명 =값,....
--where 조건식
--조건절을 사용하지 않으면 해당 컬럼이 모두 변경된다.

create table dept_temp2
as 
select * 
from dept;

select* 
from dept_temp2;

update dept_temp2
set loc = 'SEOUL';--=>loc부분이 다 서울로 바뀐다.

rollback;--=>다시 원상 복구

update dept_temp2
set dname = 'DATABASE',loc = 'SEOUL'
where deptno =40;--=>40번부서에서만 위에 2개가 바뀐다.

----------delete
--delete(데이터삭제)
--delete from 테이블명
--where 조건식
--조건절을 사용하지 않으면 모든 데이터가 삭제된다.

create table emp_temp2
as
select *
from emp;--=> 생성

select *
from emp_temp2;--=>확인

delete from emp_temp2;--  ==>emp_temp2가 삭제된다.
drop table emp_temp2;--=>테이블 완전삭제
rollback;--

delete from emp_temp2
where ename = 'SCOTT';--=>scott만 삭제됨


-------------------------------------------------트랜잭션
------------------------------TCL(데이터의 영구저장 또는 취소)
--트랜젝션
--commit,rollback,savepoint
--commit 1) 데이터 영구 저장(테이블이 데이터 반영)
--       2) create 구문을 사용해서 객체생성할때 (자동) 
--rollback 1) 데이터 변경 취소(테이블이 데이터 미반영)=원상복구
--         2) 천재지변,전쟁(자동)
--savepoint : 

create table dept01
as 
select *
from dept;

select *
from dept01;

delete from dept01;--=>명령프롬프트에 기록 남아있음.
drop table dept01;
commit;--=> 명령 프롬프트에서 기록삭제 완료됨

rollback;-->commit 이 한번 일어나면 coommit 지점으로 돌아가서 삭제된 기록이 복구는 안된다!!!

truncate table dept01;-->데이터영구삭제가 되고 롤백이 되도 데이터를 불러올 수 없다.


--------------------------------DDL(데이터정의어)-----------------
--DDL(데이터 정의어) : table 모든 객체를 생성,삭제,변경하는 명령어
--create-생성,alter-변경,drop-삭제,

--create table 테이블명(  --table(객체)
--          컬럼명1 타입, --column(속성)
--          컬럼명2 타입,
--          컬럼명3 타입   마지막에는 ,를 빼준다!!
--                       );

create table emp_ddl(
   --속성(사번,이름,직책,관리자,입사일,급일,급여,성과금,부서번호)
   empno number(4),
   ename varchar2(10), --크기는 다 byte
   job varchar2(9),
   mgr number(4),
   hiredate date,
   sal number(7,2),
   comm number(7,2),
   deptno number(2)
);

select *
from emp_DDL;

insert into emp_ddl
values (9999,'이순신','MANGER',1111,sysdate,1000,null,10);

create table dept_ddl--테이블의 복사하는용(백업or 테스트)
as
select * 
from dept;

create table dept_30
as
select * from dept
where deptno =30;

select *
from dept_30;

create table dept_m
as
select dname,loc
from dept;

create table dept_d
as
select * from dept
where 1 != 1;  -- 이 조건문의 의미는 있을 수 없는거여서  테이블의 구조만 복사한다.

------------테이블 변경(컬럼의 정보 수정)
--alter
--새로운 컬럼추가,컬럼의 이름 변경,자료형의 변경,컬럼을 삭제

create table emp_alter
as
select * from emp;

select * from emp_alter;

alter table emp_alter
add address varchar2(100);--=> emp_alter테이블에 address주소가 추가됨

alter table emp_alter
rename column address to addr;--address주소가 addr로 변경

alter table emp_alter
modify empno number(10);--=>emp_hw에 열 클릭하면 10으로 변경됨

alter table emp_alter-- addr의 행이 삭제됨
drop column addr;

--12-1문제
create table emp_hw(
empno number(4),
ename varchar2(10),
job varchar2(9),
mgr number(4),
hiredate date,
sal number(7,2),
comm number(7,2),
deptno number(2)
);
select * from emp_hw;

--12-2문제
alter table emp_hw
add BIGO varchar2(20);

--12-3문제
alter table emp_hw
modify BIGO VARCHAR2(30); 

--12-4문제
alter table emp_hw
rename column BIGO to remark;

--12-5문제
insert into emp_hw
select empno,ename,job,mgr,hiredate,sal,comm,deptno,null
from emp;

rollback;

select * from emp_hw;

drop table emp_hw;

----------------------------------------데이터사전
desc user_tables; --정보확인용

select table_name
from user_tables; --정보확인용

select owner,table_name
from all_tables;

------------------인덱스
--index : (검색속도를 향상시키기위해 사용 객체)
--index create-생성, drop-삭제
--select 구문의 검색속도를 향상 시킨다
--전체 레코드의 3%~5%정도일때 
--index객체를 컬럼에 생성해서 사용한다.

--create index 인덱스명
--on 테이블명(컬럼명);

create table emp01
as
select* from emp;

select * from emp01;--데이터 917,504까지 데이터 추가

insert into emp01
select * from emp01;

insert into emp01(empno,ename)
values(1111,'bts');

--index 객체를 생성하기전 (0.034)
select empno,ename
from emp01
where ename = 'bts';

--index생성
create index idx_emp01_ename
on emp01(ename);

--index 객체를 생성하기 후 (0.005~0.001)
select empno,ename
from emp01
where ename = 'bts';
drop table emp01;
drop index idx_emp01_ename; --index 삭제 scott에 인덱스 emp01이 삭제됨

--테이블 삭제후 원복 하는법
--show recyclebin;(휴지통역활)지워진거 보기

show recyclebin;

FLASHBACK table emp01
to before drop; --삭제된거 복구

purge recyclebin; --휴지통 삭제

-------------------------------------10.24-------------------------------------

-----------------------------------제약조건-----------------------
--p.360
--제약조건(무결성) : 잘못된 값이 데이터로 사용되는것을 못하게 하는것
--데이터 무결성 : 데이터의 정확성과 일관성 보장

-- not null : 지정한 열에 null값을 허용안함
 -- unique  --> 중복은 허용안함 
 -- primary key(기본키)(=not null+unique 둘 다 제약)
 -- foreign key(외래키=참조키)
 -- 1. 부모와 자식의 관계를 가지는 자식쪽 테이블에 설정한다.
 -- 2. 부모쪽 테이블의 컬럼은 반드시 primary key 또는 unique해야 한다.
 -- 3. null 데이터를 허용한다.
 -- check
 --default
 
 -- emp,dept
 
 
 
 insert into emp
 values (1111,'aaa','MANAGE',9999,SYSDATE,1000,NULL,50);
 
 drop table emp02;
 
 create table emp02(--테이블,열의 틀을 만든다고 생각
          empno number(4) primary key, -- (not null + unique) =primary key  
          ename varchar2(10) not null, -->not null로 제약조건을 검
          job varchar2(9),
          deptno number(2)
 );
 --기본키 사번번호로 구별함
insert into emp02--열의 데이터를 삽입 생각vs create와 비교
values (1111,'홍길동','MANAGER',30);
 
insert into emp02
values (2222,'홍길동','MANAGER',30); 
 
insert into emp02
values (null,'김유신','SALESMAN',20);  
 
insert into emp02
values (2222,'옥동자','SALESMAN',10);  
--무결성 제약 조건(SCOTT.SYS_C0011064)에 위배됩니다
--무결성 제약 조건(SCOTT.EMP02_EMPNO_PK)에 위배됩니다
delete from emp02;

 create table emp02(
          empno number(4) constraint emp02_empno_pk primary key, --제약조건을 우리가확인할수있게 변경하는법
          ename varchar2(10) constraint emp02_ename_nn not null, --constraint 제약조건명     
          job varchar2(9),
          deptno number(2)
 );


create table emp07(
       empno number(4) constraint emp07_empno_pk primary key,
       ename verchar2(9)constraint emp07_empno_nn not null,
       job varchar2(9),
       deptno number(2) constraint emp07_deptno_fk references dept07(deptno)
       );
       
create table dept07(
       deptno number(2) constraint dept07_deptno_pk primary key,
       dname varchar2(20)constraint dept07_dname_nn not null,
       loc varchar2(20)constraint dept07_dname_nn not null
);

select * 
from emp07;
select * 
from dept07;
--서브쿼리문을 사용한 데이터 삽입
insert into dept07
select * 
from dept;

insert into emp07
select empno,ename,job,deptno
from emp;

create table emp08(
empno number(4)primary key,
ename varchar2(10)not null,
sal number(7)constraint emp08_sal_ck check(sal between 500 and 5000),
gender varchar2(2) constraint emp08_gender_ck check(gender in ('M','F'))
);

select* from emp08;

insert into emp08
values(1111,'hong',1000,'M');

insert into emp08--SAL 제약조건
values(2222,'hong',200,'M');--체크 제약조건(SCOTT.EMP08_SAL_CK)이 위배되었습니다

insert into emp08--GENDER 제약조건
values(3333,'hong',1000,'A');--체크 제약조건(SCOTT.EMP08_GENDER_CK)이 위배되었습니다

create table dept08(
       deptno number(2)primary key,
       dname varchar2(10)not null,
       loc varchar2(15)default'SEOUL'
);
select*from dept08;
--default
insert into dept08(deptno,dname)
values (10,'SALES');--SEOUL 값도 삽입된다.

insert into dept08(deptno,dname,loc)
values (20,'SALES','BUSAN');

--제약조건 설정방식
--컬럼 레벨의 설정

--테이블 레벨의 설정  1)  마지막 컬럼에도 ,콤마를 붙여준다 마지막이 아니기떄문에
--                  2)  제약조건을 분리하여 작성
--                  3)  not null을 적용 할 수 없다.vs 컬럼 레벨에서만 적용한다. 
--테이블 레벨방식의 ex)
create table emp09(
       empno number(4),
       ename varchar2(20)constraint emp09_ename_nn not null,
       job varchar2(20),
       deptno number(20),
       
       constraint emp09_empno_pk primary key(empno),
       constraint emp09_job_uk unique(job),
       constraint emp09_deptno_fk foreign key(deptno) references dept(deptno)--마지막이라 ,콤마 생략
);

insert into emp09 
values(3333,'hong','PRESIDENT',80);--오류가 발생 :SCOTT.EMP09_DEPTNO_FK)이 위배되었습니다- 부모 키가 없습니다

--복합기(=기본키를 두개의 컬럼을 사용하는 경우)
--    1)테이블 레벨 방식으로만 적용 가능하다
--    2)Alter 명령어 사용방식
create table member(
       name varchar2(10),--뒤에 primary key를 사용 못한다.
       address varchar2(30),
       hphone varchar2(10),
       
       constraint member_name_address_pk primary key(name,address)
       );
       
create table emp10(
       empno number(4),
       ename varchar2(20),
       job varchar2(20),
       deptno number(20)-- ,콤마 없다 주의하기!!
);

alter table emp10--제약 조건이 생성
add  constraint emp10_empno_pk primary key(empno);

alter table emp10--제약 조건이 생성
add  constraint emp10_empno_fk foreign key(deptno) references dept(deptno);

--not null은 변경해주는 개념=>modify를 사용(null-> not null)

--modify
alter table emp10--제약 조건이 생성
modify job constraint emp10_job_nn not null;

alter table emp10--제약 조건이 생성
modify ename constraint emp10_ename_nn not null;

--drop : 제약조건명(constraint) 또는 제약조건(primary key)을 사용한다.
alter table emp10--제약조건 삭제
drop constraint emp10_empno_pk;--or drop  primary key(empno);

create table emp11(--자식     부모꺼먼전 실행후 자식꺼 실행
       empno number(4),
       ename varchar2(20),
       job varchar2(20),
       deptno number(20)-- ,콤마 없다 주의하기!!
);

alter table emp11--제약 조건이 생성
add  constraint emp11_empno_pk primary key(empno);

alter table emp11--제약 조건이 생성
add  constraint emp11_deptno_fk foreign key(deptno) references dept11(deptno);

create table dept11(--부모
       deptno number(2),
       dname varchar2(10),
       loc varchar2(15)
);

alter table dept11
add constraint dept11_deptno_pk primary key(deptno);

insert into dept11
select*
from dept;

insert into emp11
select empno, ename, job, deptno 
from emp;

delete from dept11--처음엔 부모를 삭제할 수 없다   단) cascads를 사용하면 삭제 가능
where deptno = 10;--오류가 난다 '자식 레코드가 발견되었습니다'

alter table dept11--이 코드를 실행하면 부모를 삭제할 수 있다
disable primary key cascade;

alter table dept11--이 코드를 실행하면 부모를 삭제할 수 있다
drop primary key cascade;


--14-1문제,ALTER tabel 명령어로 제약조건을 설정하세요
create table DEPT_CONST(--부모테이블
deptno number(2),
dname varchar2(14),
loc varchar2(13)
);

alter table DEPT_CONST
add constraint DEPT_CONST_deptno_pk primary key(deptno);

alter table DEPT_CONST
add constraint DEPT_CONST_dname_unq unique(dname);

alter table DEPT_CONST
modify loc constraint DEPT_CONST_loc_nn not null;

--14-2문제 
create table emp_const( --자식테이블
       empno number(4),
       ename varchar2(10),
       job varchar2(9),
       tel varchar2(20),
       hiredate date,
       sal number(7),
       comm number(7),
       deptno number(2) -- ,콤마 없다 주의하기!!
);

alter table emp_const
add constraint emp_const_empno_pk primary key(empno);

alter table emp_const
modify ename constraint emp_const_ename_nn not null;

alter table emp_const
add constraint emp_const_tel_unq unique(tel);

alter table emp_const
add constraint emp_const_sal_chk check(sal between 1000 and 9999);

alter table emp_const
add constraint emp_const_deptno_fk foreign key(deptno)references dept_const(deptno);

-------------------------뷰(view)-----------------------
--p.338

--팁--
--이름	            조작	           SQL
--Create	        생성	           INSERT
--Read             읽기(또는 인출)   SELECT
--(=Retrieve)  	
--Update 	        갱신            UPDATE
--Delete           삭제(또는 파괴)   DELETE
--(=Destroy)	

--객체 : create로 만들어지는거  ex)table, index,view
--create or replace view + 뷰테이블명[alias]  [ ]:선택사항 필수아님
--as
--서브쿼리(select=중첩되는부분)
--[with check option]
--[with read only]

create table dept_copy
as
select*
from dept;

create table emp_copy--복사되는 테이블은 제약조건이 안 넘어온다.
as
select*
from emp;

alter table emp_copy--제약조건 생성
add CONSTRAINT emp_copy_deptno_fk foreign key(deptno)references dept(deptno);

select * from emp;  --14개
select * from emp_copy;--14개

create or replace view emp_view30--system 테이블로 권한을 먼저 허용해줘야 한다.시스템 테이블에 grant create view--view30 to scott 작성한다.
as
select empno,ename,sal,deptno 
from emp_copy
where deptno = 30;

select*
from emp_view30;

insert into emp_view30--원본테이블에 들어가 있다
values (1111,'hong',1000,30);

select*--원본테이블
from emp_copy;

insert into emp_view30(empno,ename,sal)--원본테이블에 들어가 있다
values (2222,'hong',2000);

select*
from emp_view30;

select*
from emp_copy;

insert into emp_view30(empno,ename,sal,deptno)
values (2222,'hong',2000,50);

create or replace view emp_view(사원번호,사원명,급여,부서번호)
as
select empno,ename,sal,deptno
from emp_copy;

select*
from emp_view
where 부서번호=20;--emp_view(사원번호,사원명,급여,부서번호)별칭으로 했기떄문에 한글로 한다.

create or replace view emp_dept_view
as
select empno,ename,sal,e.deptno,dname,loc
from emp e inner join dept d
on e.deptno = d.deptno
order by empno desc;

select*
from emp_dept_view;--empnp가 내림차순

---------------------------------------------------10.25-------------------
--5일차에 배운 뷰와 연결

--부서별 최소급여와 최대급여,dname min_sal max_sal
create or replace view sal_view --모든객체의 이름은 중복될 수 없지만 or replace 때문에 select에 열에'avg(sal)'을 추가해서 다시 테이블생성 가능하다.
as
select dname, min(sal) as min_sal, max(sal) as max_sal,avg(sal) as avg_sal
from emp e inner join dept d 
on e.deptno = d.deptno
group by d.dname;--부서별

select*
from sal_view;

drop view sal_view;

--with check option
create or replace view view_chk30
as
select empno,ename,sal,comm,deptno
from emp_copy
where deptno = 30 with check option;--조건절의 컬럼을 수정하지 못하게한다.

update view_chk30
set deptno = 10;--with check option;--조건절의 컬럼을 수정하지 못하게한다.

--with read only
create or replace view view_read30
as
select empno,ename,sal,comm,deptno
from emp_copy
where deptno = 30 with read only;--모든 컬럼에 대한 crud중 c,u,d가 불가능(조회만 가능하다) read만 가능하다

update view_read30
set deptno = 10;--읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다=>with read only;이거 때문에

--뷰의 활용
--TOP - N 조회하기
--Rownum(의사컬럼) 
select * 
from emp;

--입사일이 가장 빠른 5명의 사원을 조회
select *--먼저 조회
from emp
order by hiredate asc;
--1번째 방법
select *
from emp
where hiredate <='81/05/01'; 

--2번째 방법 
select rownum,empno,ename,hiredate
from emp
where rownum <=5;

--order by를 이용핸 순서대로 뷰 테이블생성
create or replace view view_hiredate
as
select empno,ename,hiredate
from emp
order by hiredate asc; 

select*
from view_hiredate;

select rownum,empno,ename,hiredate
from view_hiredate
where rownum <= 5;

--2번째~5번째 조회해보기
select rownum,empno,ename,hiredate
from view_hiredate
where rownum between 2 and 5;--rownum은 조건절에 사용시 반드시 1를 포함하는 식으로 만들어야 한다.

create or replace view view_hiredate_rm
as
select rownum rm,empno,ename,hiredate  --rm를 추가해 별칭으로 하면 1를 포함하는 식으로 만들수 있다.
from view_hiredate;

--2번째~5번째 조회해보기
select rm,empno,ename,hiredate
from view_hiredate_rm
where rm >1 and rm <=5;--(=where rm between 1 and 5)

----2번째~5번째를 
--인라인뷰로 표현방법
select rm,b.*--(=empno,ename,hiredate)
from(select rownum rm,a.*--(=empno,ename,hiredate)  
     from(select empno,ename,hiredate 
          from emp
          order by hiredate asc
          )a
     )b
    where rm > 1 and rm<=5;


--입사일이 가장 빠른 5명을 조회 인라인뷰로
select empno,ename,hiredate  
from(select empno,ename,hiredate 
     from emp
     order by hiredate asc
     )    
where rownum <=5; 

------------------------------------시퀀스
--p.344
--자동으로 번호를 증가시키는 기능수행
--create-생성,drop-삭제
--nextval,currval

--create sequence 시퀀스명
--start with    시작값 =>1이 기본값
--increment by  증가값 =>1이 기본값
--maxvalue      최대값 =>10의 1027
--minvalue      최소값 =>10의 -1027

create sequence dept_deptno_seq
increment by 10
start with 10;

select dept_deptno_seq .nextval--실행 할 때 마다 증가
from dual;

select dept_deptno_seq .currval--현재 값 확인
from dual;

create sequence emp_seq
start with 1
increment by 1
maxvalue 1000;

drop table emp01;

create table emp01
as
select empno,ename,hiredate 
from emp
where 1!=1;

select* from emp01;

insert into emp01
values (emp_seq.nextval,'hong',sysdate);--실행 할 때 마다 증가

create table product(
pid varchar(10),
pname varchar(10),
price number(5),
constraint product_pid_pk primary key(pid)
);

create sequence idx_product_id--index 객체 생성
start with 1000;

insert into product(pid,pname,price)
values ('pid' || idx_product_id.nextval,'치즈',2000);

select * from product;

-----------------------------------------------사용자관리
--p.396
--사용자관리
--create,drop
--create user 계정명 identified by 패스워드 
create user user01 
identified by 1234;

grant create session
to user01;
--DCL(제어어)
--grant(권한부여),revoke(권한회수)

--p396
-- 사용자 관리(객체)
-- 관리자 계정에서 가능(system)
-- create, drop
-- create user 계정명 identified by 패스워드
-- alter user 계정명 identified by 패스워드
-- drop user 계정명 cascade

--시스템계정으로연결
create user user01 identified by 1234; 
--> user USER01 lacks CREATE SESSION privilege; logon denied 오류뜸
grant CREATE SESSION
to user01;

-- DCL(제어어)
-- grant(권한부여), revoke(권한회수)
-- grant 시스템권한 to 계정명
-- revoke 시스템권한 from 계정명

--user01계정으로 연결
create table test
(
  id varchar2(10)
); -->권한이 불충분합니다

--시스템계정으로 연결
grant create table
to user01;
--그러고 다시 위에 실행


--시스템계정으로 연결
grant create table --권한부여
to user01;

revoke create table --권한회수
from user01;

create user user01 identified by 1234; -->생성 하고싶을때 

drop user user01 CASCADE; -->삭제 하고싶을때 

alter user user01 identifide by tiger;-->비밀번호 변경하고싶을때


--user01 연결
insert into test
values('aaa'); --> 테이블스페이스 'USERS'에 대한 권한이 없습니다.

--시스템계정으로 연결
alter user user01
quota 2m on USERS;
-->다시 위에 실행 


-- 시스템 권한(create ....)
-- 객체 권한  (select, ....)

--user01 연결
select * from emp;-->오류뜸

--scott 연결
--grant 객체권한 종류 
--on 객체명
--to 계정명

grant select
on emp
to user01;
-->권한을준다

--user01 연결
select * from scott.emp;

--다쓰고나면 회수 scott연결
revoke select
on emp
from user01;

----- p412
--롤
--시스템계정접속
create user user02 identified by 1234;

grant connect,resource
to user02;

--user02 접속
create table test(
   id varchar2(10)
);

insert into test
values('aaa');

--시스템계정 접속
create user nbac identified by 1234;

grant DBA,connect,resource
to nbac;

-- system == nbac

--nbac접속
create user user03 identified by 1234;

-- 사용자 정의롤
-- 관리자 계정에서만 가능
-- create role 롤명 
-- grant 권한 to 롤명

--시스템계정,nbac 접속
create role mrole;

grant create session,create table,create view -- 시스템 권한
to mrole;

create user user04 identified by 1234;

grant mrole
to user04;

--user04접속
create table test(
   id varchar2(10)
);   

insert into test
values ('aaa'); -->실행시 '테이블스페이스 'USERS'에 대한 권한이 없습니다' 

--시스템계정 접속
alter user user04
quota 2m on users; -->권한부여

--user4로 다시실행
insert into test
values ('aaa'); 

select * from test;

--시스템계정접속
--관리자 권한에서 롤 생성
create role mrole2;

--객체권한은 해당 사용자 계정에서 가능
--scott 접속
grant select 
on emp
to user04;

-- 롤 권한은 관리자 계정에서만 가능 ,시스템계정 접속
grant mrole2
to user04; -->user04는 select할수있는 권한을 얻음

--user04접속
select * from scott.emp;

--시스템계정 접속
create user user05 identified by 1234;

grant connect,resource
to user05;

--user05접속
select * from user_role_privs;  

select * from scott.emp; -->오류

--시스템계정 접속
create role mrole3;

--scott계정 접속
grant select
on emp
to mrole3;

--시스템계정 접속
grant mrole3
to user05;

--user05접속

select * from user_role_privs;  

set role all; -- ?

select * from scott.emp;

--시스템계정접속
revoke mrole3
from user05;


-----------------------------------------10.26-----------------------------

--p.419
---------------------PL/SQL구조(확장되어진 SQL 언어)
--변수,조건문,반복문 사용한다
--declare(선언부) (선택구문)
--   변수정의 ex)vempno number(4);  컬럼명은 상관없다.
--              vename verchar2(10); 
--begin(실행부)  (필수구문)
--   SQL구문 작성
--   출력구문 작성 --쿼리문의 수행결과를 반드시 출력함수를 통해서 확인해야한다.
--exception(예외 처리부)(선택구문)
--   예외처리구문 작성
--end;(필수구문)
--/  슬러시 빼먹지 않게 주의!!

select * from emp;

--Hello PL/SQL 출력하기
set serveroutput on;    --실행결과를 먼저 출력해야한다!!

begin
dbms_output.put_line('Hello,PL.SQL!');--출력함수
end;
/   --Hello,PL.SQL! PL/SQL 프로시저가 성공적으로 완료되었습니다.


--변순 선언 및 변수 값 출력하기

declare
--vempno number(4); --변수의선언
--vename varchar2(10);
vempno number(4) := 7777;
vename varchar2(10) not null := 'SCOTT';--nullㄱ밧을 변수의 값으로 사용할수 없다. 
begin
vempno := 7777; --변수의 초기화
vename := 'SCOTT'; 
dbms_output.put_line('사원 /이름');
dbms_output.put_line('vempno :' ||  vename);
end;
/



----스칼라 방식
----레퍼런스 방식
--  1.emp.empno%type
--  2.emp%rowtype%
----사용자 정의 변수 타입
--  1.테이블type
--  2.레코드type
  
declare
--스칼라 방식
--vempno number(4);

--레퍼런스(참조형) 방식
vempno emp.empno%type := 7777; -- .+ % 참조의 의미 기존테이블의 컬럼의 타입을 참조한다.

begin
--vempno := 7777;
dbms_output.put_line(vempno);
end;
/


--레퍼런스(참조형) 방식 : --테이블에서 값을 가져오기때문에 대부분 레퍼런스 방식을 사용
declare
vempno emp.empno%type;
vename emp.ename%type;

begin
  select empno,ename 
  into vempno,vename--(필수적으로 적기)
  from emp;--where절을 사용할때는 ;세미클론 사용안하고 ,exception방식을 사용할 경우에는 ;세미클론을 사용해준다.
-- where empno = 7788;--(필수적으로 적기)
  dbms_output.put_line('사번 /이름');
  dbms_output.put_line(vempno|| ' ' || vename);

exception--where절을 생략했을때 예외값으로 사용한다.
 when TOO_MANY_ROWS then dbms_output.put_line('행의수가 여러개 입니다.');
 when others then dbms_output.put_line('모든 예외에 대한 처리');
end;
/


--테이블type(사용자 정의 변수의 타입을 정의한다)
--배열의 형식
--vename varchar2(10)

--컬럼 참조해서 출력하기
declare  --대문자는 고정 소문자는 임의로 설정
  TYPE ename_table_type IS TABLE OF emp.ename%type
  INDEX BY BINARY_INTEGER;
  
  TYPE job_table_type IS TABLE OF emp.job%type
  INDEX BY BINARY_INTEGER;
  
  enameArr ename_table_type; --배열형식의 변수 선언
  jobArr job_table_type;     --배열형식의 변수 선언
  i BINARY_INTEGER :=0;      --
begin
  for k in (select ename,job from emp)loop
  i := i+1;
  enameArr(i):= k.ename;
  jobArr(i) := k.job;
  end loop;
  
  for j in 1..i loop
    dbms_output.put_line(enameArr(j) || ' / '|| jobArr(j));
  end loop;
end;
/
--결과값
--SMITH / CLERK
--ALLEN / SALESMAN
--WARD / SALESMAN


-----record레코드 타입변수
--여러개의 변수를 묶어서 사용한다.=>사용자 정의 변수 타입
--클래스랑 유사하다.
declare
 TYPE emp_record_type IS RECORD(
   v_empno emp.empno%type,
   v_ename emp.ename%type,
   v_job emp.job%type,
   v_deptno emp.deptno%type
   );
   
   emp_record emp_record_type; 
   --변수이름 + 데이터타입(자료형,숫자형)이라고 생각하자; 레코드타입안에 위 내용코드가 들어가있다. 

begin
  select empno,ename,job,deptno
  into emp_record --변수 선언했기 때문에 다 안적어도 된다
  from emp 
  where empno = 7788;
  
  dbms_output.put_line(emp_record.v_empno ||' '||emp_record.v_ename ||' '||emp_record.v_job ||' '||emp_record.v_deptno);
end;
/--=>7788 SCOTT ANALYST 20 PL/SQL 프로시저가 성공적으로 완료되었습니다.

create table dept_record
as
select* from dept;

-------레코드를 사용한 insert
--삽입,수정 할때는 레코드르 사용할 테이블을 만들어준다.
declare 
 TYPE rec_dept IS RECORD(
      v_deptno dept_record.deptno%type,
      v_dname dept_record.dname%type,
      v_loc dept_record.loc%type
 );
  dept_rec rec_dept;--변수를 설정한거   ,테이블명과 변수(레코드)이름 중복하면안된다,, 
  
 begin
    dept_rec.v_deptno := 50;
    dept_rec.v_dname := 'DEV';
    dept_rec.v_loc := 'BUSAN';
    
    insert into dept_record
    values dept_rec;--원칙은 ('','','') 각각 1대1 매칭으로 사용하지만 레코드변수는 괄호를 이용한해도된다
 end;
 /
select * from dept_record;
--10	ACCOUNTING	NEW YORK
--20	RESEARCH	DALLAS
--30	SALES	    CHICAGO
--40	OPERATIONS	BOSTON
--50	DEV	        BUSAN
--50	DEV      	BUSAN

--------위 컬럼을 레코드를 사용한 update하기
--set절은 row키워드와 함께 레코드 이름을 명시한다
--행 전체의 데이터를 바꿔준다
declare 
 TYPE rec_dept IS RECORD(
      v_deptno dept_record.deptno%type not null := 99,
      v_dname dept_record.dname%type,
      v_loc dept_record.loc%type
 );
   dept_rec rec_dept;
 begin
  dept_rec.v_deptno := 50;
  dept_rec.v_dname := 'INSA';
  dept_rec.v_loc :='SEOUL';
  
  update dept_record
  set dname = dept_rec.v_dname,loc = dept_rec.v_loc
  where deptno = dept_rec.v_deptno;
  
 end;
 /
 
 select*from dept_record;--결과조회하기
--10	ACCOUNTING	NEW YORK
--20	RESEARCH	DALLAS
--30	SALES	CHICAGO
--40	OPERATIONS	BOSTON
--50	INSA	SEOUL
--50	INSA	SEOUL


--50번 부서 삭제하기
declare
  v_deptno dept_record.deptno%type := 50;
 begin
  delete from dept_record
  where deptno = v_deptno;
 end;
 /
 
 select*from dept_record;--결과조회하기
--10	ACCOUNTING	NEW YORK
--20	RESEARCH	DALLAS
--30	SALES	CHICAGO
--40	OPERATIONS	BOSTON

--------------------------if 조건문
--조건문
--if then end  if;
--if then else end if;
--if then elsif then end if;

declare
  vempno number(4);
  vename varchar2(10);
  vdeptno varchar2(10);
  vdname varchar2(10) :=null;
begin
  select empno,ename,deptno
  into vempno,vename,vdeptno
  from emp
  where empno = 7788;
  
  if(vdeptno = 10)then 
       vdname := 'AAA';
  end if;
  
  if(vdeptno = 20)then 
       vdname := 'BBB';
       end if;
  
  if(vdeptno = 30)then 
       vdname := 'CCC';
       end if;
  
  if(vdeptno = 40)then 
       vdname := 'DDD';
  end if;
 
  dbms_output.put_line('부서명 : '|| vdname);

end;
/

----------------%rowtype
--테이블의 모든 컬럼의 이름과 타입을 참조하겠다.
--컬럼명이 변수명으로 사용되고 컬럼의 타입을 변수의 타입으로 사용한다.
declare
  vemp emp%rowtype;
  
begin
 select* 
 into vemp
 from emp
 where empno = 7788;

 dbms_output.put_line('사번 : ' ||vemp.empno);
 dbms_output.put_line('이름 : ' ||vemp.ename);
 dbms_output.put_line('부서 : ' ||vemp.deptno);
 dbms_output.put_line('입사일 : ' ||vemp.hiredate);
 dbms_output.put_line('상여금 : ' ||vemp.comm);--빈칸은 null를 나타낸다.
end;
/
--사번 : 7788
--이름 : SCOTT
--부서 : 20
--입사일 : 87/04/19
--상여금 : 


----------------------------------------------------------------------------
--rowtype  
--해당사원의 연봉(emp테이블에 있다)을 출력하세요.단) 커미션이 null인경우 0으로 계산되게하세요.
--계산된 연봉을 변수annsal에 넣어서 출력하세요
declare
  vemp emp%rowtype;
  annsal number(7,2);

begin
  dbms_output.put_line('사번/이름/연봉');
  dbms_output.put_line('------------');
  
  select*
  into vemp
  from emp
  where empno = 7788;

  if(vemp.comm is null)then
      vemp.comm := 0;
  end if;
  annsal := vemp.sal*12 + vemp.comm;
  dbms_output.put_line(vemp.empno || ' ' || vemp.ename || ' '||annsal);
end;
/
--사번/이름/연봉
--------------
--7788 SCOTT 36000

declare
  vemp emp%rowtype;
  annsal number(7,2);  --숫자7자리중에 2자리를 소수를 위해 쓰겠다
begin
  dbms_output.put_line('사번/이름/연봉');
  dbms_output.put_line('------------');
  
  select*
  into vemp
  from emp
  where empno=7788;

  if(vemp.comm is null)then
     annsal := vemp.sal*12;
 else 
     annsal:= vemp.sal*12+vemp.comm;
  end if;
 
  dbms_output.put_line(vemp.empno || ' ' || vemp.ename || ' '||annsal);
end;
/
--사번/이름/연봉
--------------
--7788 SCOTT 36000

declare
  vemp emp%rowtype;
  vdname varchar2(10);
begin
  select*
  into vemp
  from emp
  where empno = 7788;
  if(vemp.deptno = 10)then
     vdname := 'AAA';
  elsif (vemp.deptno = 20)then
     vdname := 'BBB';
  elsif (vemp.deptno = 30)then
     vdname := 'CCC';
  elsif (vemp.deptno = 40)then
     vdname := 'DDD';
  end if;
  dbms_output.put_line(vdname);
end;
/--=>BBB

-----------------------------------반복문
--loop
--loop end loop;
--for in loop end loop;
--while loop end loop;
--  실행문(무한반복문)
--  무한반복문의 제어
--  1.exit when 조건식;
--  2.if then end if;
--end loop;

declare
  n number := 1;
begin
  loop
    dbms_output.put_line(n);
    n := n+1;
    exit when n >10; --n이 10보다 초과하면 exit한다.(종료조건)
  end loop;
end;
/--=>1~10까지 나온다.

declare 
begin
--in 구문뒤에 작성되는 값이 반복의 횟수를 결정한다.
   for n in 1..10 loop --in 시작값..종료값 '..'=>1씩증가 1~10(10회반복)
    dbms_output.put_line(n);
   end loop;
end;
/
--=>1~10까지 나온다.

declare 
  
begin
--in 구문뒤에 작성되는 값이 반복의 횟수를 결정한다.
   for n in reverse  1..10 loop --in 시작값..종료값 '..'=>1씩감소 10~1(10회반복)
    dbms_output.put_line(n);
   end loop;
end;
/
--=>10~1까지 나온다.

declare
   vdept dept%rowtype;
begin
   for n in 1..4 loop
    select*
    into vdept
    from dept
    where deptno =10*n;
    dbms_output.put_line(vdept.deptno ||' '|| vdept.dname ||' '|| vdept.loc);
   end loop; 
end;
/
--1~4를 10*n에 대입되면서 값이 나온다.
--10 ACCOUNTING NEW YORK
--20 RESEARCH DALLAS
--30 SALES CHICAGO
--40 OPERATIONS BOSTON

------------------while문
declare
  n number := 1;
begin
  while(n <= 10)loop
      dbms_output.put_line(n);
      n := n+1;
  end loop;
end;
/
--=>1~10

--40까지 while문으로 구하기
declare
     vdept dept%rowtype;
     n number :=1;
begin
    while(n<=4) loop
        select *
       into vdept
       from dept
       where deptno = 10 * n;
     dbms_output.put_line(vdept.deptno||''||vdept.dname||''||vdept.loc);
          n := n +1;
    end loop;
end;
/
--10ACCOUNTINGNEW YORK
--20RESEARCHDALLAS
--30SALESCHICAGO
--40OPERATIONSBOSTON


--------------------------------------10.27---------------------------------

--p.481
--저장 프로시져
-----1)생성(create)
-----2)실행(execute or exec)

--저장프로시져의 매개변수 유형(in,out,in out)
--in : 값을 전달받는 용도
--out : 프로시져 내부의 실행 결과를 실행을 요청한 쪽으로 전달
--in out : in + out

--기본형태
--create or replace procedure 프로시져이름
--is (or as)  
--  변수정의
--begin
--  실행부,출력구문,조건문,반복문
--end;
--/

drop table emp01;

set serveroutput on; --PL/SQL할 때 먼저 실행해줘야 코드가 실행됨

create table emp01
as
select*
from emp;

create or replace procedure emp01_print--이름은 임의로 지정
is
 vempno number(10);
 vename varchar2(10);
begin
vempno := 1111;
vename := 'Hong';
dbms_output.put_line(vempno||' ' || vename);
end;
/
--=>Procedure EMP01_PRINT이(가) 컴파일되었습니다.

exec emp01_print;--=>1111 Hong

--익명 블록에서 프로시저 실행하기
begin
emp01_print;
end;
/

-- 프로시져 삭제하기
creat or replace procedure emp01_del
is
begin
  delete from emp01;
end;
/

exec emp01_del;

select* from emp01;--=>삭제해서 빈칸이 나온다.

drop table emp01;

create table emp01--다시 생성하고 다른 방법으로 시작하려고 생성함
as
select*
from emp;

--매개변수를 이용한 프로시져
create or replace procedure del_ename(vename emp01.ename%type) --(매개변수 +데이터타입)
is
begin
  delete from emp01
  where ename = vename;
end;
/

exec del_ename('SCOTT');

select * from emp01
where ename = 'SCOTT';--=>SCOTT 부분이 빠져있다.

exec del_ename('SMITH');--=>SMITH 부분이 삭제됐다.
select * from emp01;

---------저장프로시져의 매개변수 유형(in,out,in out)
--in : 값을 전달받는 용도
--out : 프로시져 내부의 실행 결과를 실행을 요청한 쪽으로 전달
--in out : in + out


--매개변수로 이용하고 사번을 통해서 특정 사원을 조회하기
create or replace procedure sel_empno
( vempno in emp.empno%type,--(매개변수 +데이터타입)에 가운데에 in을 추가한거
  vename out emp.ename%type,
  vsal out emp.sal%type,
  vjob out emp.job%type
)
is

begin
  select ename,sal,job
  into vename,vsal,vjob
  from emp
  where empno = vempno;
end;
/
--바인드변수 만들기--한개씩 블록처리해서 실행해준다
variable var_ename varchar2(15);
variable var_sal number; --숫자일 땐 타입만 정해주고 크기는 정해주지 않는다
variable var_job varchar2(15);

--바로 위에 코드를 가지고오고 바인드변수다
exec sel_empno(7499,:var_ename,:var_sal,:var_job);--7499사원을 조회하기
--'SEL_EMPNO' 식별자가 정의되어야 합니다 생성자를 오타
print var_ename;--=>ALLEN  --한개씩 블록처리해서 실행하기
print var_sal;--=>    1600
print var_job;--=>SALESMAN

--사원정보를 저장하는 저장 프로시저 만들기
--사번,이름,직책,매니저,부서
--사원 정보는 매개변수 사용해서 받아온다.

drop table emp02;--전에 만든게 있어서 삭제하고 다시 생성

create table emp02
as
select empno,ename,job,mgr,deptno
from emp
where 1 !=1;
--(매개변수 +데이터타입)에 가운데에 in을 추가한거
create or replace procedure insert_sawon
( vempno in emp02.empno%type,
  vename in emp02.ename%type,
  vjob in emp02.job%type,
  vmgr in emp02.mgr%type,
  vdeptno in emp02.deptno%type
)
is
begin
  insert into emp02
  values( vempno,vename,vjob,vmgr,vdeptno);
end;
/

exec insert_sawon(1111,'hong','sales',2222,10);--=>emp테이블에 사원이 추가된다

select* from emp02;--=>1111	hong	sales	2222	10

--저장함수와 저장프로시저의 차이점 : return값 유무
--1).생성(create)
--2).실행(exec)
--기본형태
--------create or replace function 함수명(매개변수)
--   return 값의 타입 --세미클론 생략
--is
--begin
--   SQL구문
--   출력함수
--   조건문, 반복문
--   return 리턴값; --세미클론 사용
--end;
--/

--사원에 함수를 이용해서 보너스를 구하기
create or replace function cal_bonus(vempno emp.empno%type)
   return number
is
   vsal number(7,2);
begin
   select sal
   into vsal
   from emp
   where empno=vempno;
   return vsal*200;
end;
/

variable var_res number;

exec :var_res := cal_bonus(7788); --exec뒤에 바인드변수를 선언해야한다.

print :var_res;
--   VAR_RES
------------
--    600000

--삭제하기
drop procedure insert_sawon;

drop function cal_bonus;


----------------------커서
--p.460 
--커서 : select구문이 실행하는 결과를 가리킨다.

----기본형태
--declare
--  cursor 커서명 is sql문(select);  --커서의 선언
--  vemp emp%rowtype;
--begin
--  open 커서명;
--  loop
--  fetch 커서명 into 변수명;--바로밑에 end loop구문과 같이 사용한다.,테이블로부터 가져와서 변수에 저장하는 역활
--  exit when 커서명%notfound;
--  end loop;
--  close 커서명;
--  select*
--  into 변수
--  from emp;
--  --where 조건식
--end;
--/

declare
  cursor c1 is select*from emp;  
  vemp emp%rowtype;
begin
  open c1;
  loop
  fetch c1 into vemp;--바로밑에 end loop구문과 같이 사용한다.,테이블로부터 가져와서 변수에 저장하는 역활
  exit when c1%notfound;
  dbms_output.put_line(vemp.empno|| ' ' ||vemp.ename|| ' '|| vemp.job|| ' ' ||vemp.mgr|| ' ' ||vemp.deptno|| ' '|| vemp.comm|| ' '||vemp.sal|| ' ' ||vemp.hiredate);
  end loop;
  close c1;
end;
/
--7369 SMITH CLERK     7902 20  800 80/12/17
--7499 ALLEN SALESMAN  7698 30  300 1600 81/02/20
--7521 WARD SALESMAN   7698 30  500 1250 81/02/22
--7566 JONES MANAGER   7839 20  2975 81/04/02
--7654 MARTIN SALESMAN 7698 30  1400 1250 81/09/28
--7698 BLAKE MANAGER   7839 30  2850 81/05/01
--7782 CLARK MANAGER   7839 10  2450 81/06/09
--7788 SCOTT ANALYST   7566 20  3000 87/04/19
--7839 KING PRESIDENT  10  5000 81/11/17
--7844 TURNER SALESMAN 7698 30  0 1500 81/09/08
--7876 ADAMS CLERK     7788 20  1100 87/05/23
--7900 JAMES CLERK     7698 30  950 81/12/03
--7902 FORD ANALYST    7566 20  3000 81/12/03
--7934 MILLER CLERK    7782 10  1300 82/01/23

declare
   cursor c1 is select * from dept;
   vdept dept%rowtype;
begin
   for vdept in c1 loop
   exit when c1%notfound;
   dbms_output.put_line(vdept.deptno||' ' ||vdept.dname||' ' ||vdept.loc);
   end loop;
end;
/
--10 ACCOUNTING NEW YORK
--20 RESEARCH DALLAS
--30 SALES CHICAGO
--40 OPERATIONS BOSTON

--아이디,이름,이름의 성,부서이름 조인방식으로 조회하기
--hr의 테이블 employees,departments, hr계정으로 접속해서 실행하기
select employee_id,first_name,last_name,department_name
from employees e inner join departments d
on e.department_id = d.department_id--=>106의 행들이 나옴
where e.department_id = 100;--=>6명의 사원들이 나옴

select count(*) from employees;--=>107

select*from employees
where department_id is null;--직원중 department_id is가 null인경우

--서브쿼리로 조회하기 hr계정으로 접속해서 실행하기
select employee_id ,first_name, last_name,department_id,
            (select department_name
             from departments d
             where e.department_id = d.department_id
             )as dep_names 
from employees e
where department_id = 100;--=>6명의 사원들이 나옴(위에 조인과 같은 결과나온다.)

---프로시저 함수로 조회하기, hr계정으로 접속해서 실행하기
create or replace  function get_dep_name(dept_id number)
   return varchar2--타입만 지정해주기
is
   sdepname varchar2(30);
begin
   select department_name
   into sdepname
   from departments
   where department_id = dept_id;
   return sdepname; 
end;
/

variable var_depname varchar2(30);

exec :var_depname := get_dep_name(90);

print :var_depname;--=>Executive가 나온다.

--조인,서브쿼리,함수와 같은 결과값나온다 hr에서 실행하기
select employee_id ,first_name, last_name,(department_id)
from employees e
where e.department_id = 100;
--108	Nancy	Greenberg	100
--109	Daniel	Faviet	    100
--110	John	Chen	    100
--111	Ismael	Sciarra	    100
--112Jose Manuel Urman	    100
--113	Luis	Popp	    100
